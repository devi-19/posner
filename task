from psychopy import visual, core, data, gui, hardware, event
from psychopy.hardware import keyboard
import os
import numpy as np  # Needed for calculating averages

# --- 1. Setup Info & Files ---
info = {'participant': '', 'session': '001'}
dlg = gui.DlgFromDict(info, title='Posner Task v3')
if not dlg.OK:
    core.quit()

info['dateStr'] = data.getDateStr()

if not os.path.exists('data'):
    os.makedirs('data')
filename = f"data/{info['participant']}_{info['dateStr']}"

thisExp = data.ExperimentHandler(name='Posner', version='3.0',
                                 extraInfo=info, 
                                 dataFileName=filename)

# --- 2. Hardware Setup ---
win = visual.Window([1024,768], fullscr=False, units='pix', color='black')
kb = keyboard.Keyboard()
mouse = event.Mouse(win=win) # Initialize the mouse

# --- 3. Stimuli Setup ---
fixation = visual.Circle(win, size=10, lineColor='white', fillColor='lightGrey')
probe = visual.GratingStim(win, size=80, tex=None, mask='gauss', color='green')
cue = visual.ShapeStim(win, vertices=[[-30,-20], [-30,20], [30,0]],
                       lineColor='red', fillColor='salmon')

# --- 4. Setup "Button" and Text ---
# The Instruction Text
welcome_txt = visual.TextStim(win, text="Welcome to the Posner Task.\n\n"
                                        "1. Keep your eyes on the center dot.\n"
                                        "2. An arrow will appear (the cue).\n"
                                        "3. A green dot will appear (the target).\n"
                                        "4. Press LEFT or RIGHT arrow keys to match the dot.\n\n"
                                        "Click the button below to start.",
                              height=24, color='white', pos=(0, 50))

# The Button Shape (A rectangle)
start_button = visual.Rect(win, width=200, height=80, pos=(0, -150),
                           fillColor='darkgrey', lineColor='white')

# The Button Text
start_label = visual.TextStim(win, text="START", height=30, pos=(0, -150), color='black')

# The Results Text (Empty for now)
results_txt = visual.TextStim(win, text="", height=24, color='white')


# --- 5. Timing Config ---
fix_frames = 30   
cue_frames = 48   # Slower setting (0.8s) based on your preference
probe_max_frames = 120 

# --- 6. Define Loops ---
try:
    conditions = data.importConditions('conditions.csv')
except FileNotFoundError:
    print("Error: conditions.csv not found!")
    core.quit()

practice_loop = data.TrialHandler(conditions, nReps=1, method='random', name='practice')
main_loop = data.TrialHandler(conditions, nReps=5, method='random', name='main')
blocks = [practice_loop, main_loop]

# =========================================================
# PART A: THE CLICKABLE WELCOME SCREEN
# =========================================================
# We loop until the mouse is pressed INSIDE the button
button_pressed = False
while not button_pressed:
    # Draw visuals
    welcome_txt.draw()
    start_button.draw()
    start_label.draw()
    win.flip()
    
    # Check for click
    if mouse.isPressedIn(start_button):
        button_pressed = True

# Brief pause after click before starting
core.wait(0.5)
# =========================================================
# PART B: THE EXPERIMENT LOOPS (UPDATED)
# =========================================================
for current_loop in blocks:
    
    # 1. Show Block Instructions
    if current_loop.name == 'practice':
        msg = "Practice Block.\nPress SPACE."
    else:
        msg = "Main Block (Data Recording).\nPress SPACE."
    
    visual.TextStim(win, text=msg).draw()
    win.flip()
    event.waitKeys(keyList=['space'])

    thisExp.addLoop(current_loop)

    for thisTrial in current_loop:
        probe.setPos([thisTrial['probeX'], 0])
        cue.setOri(thisTrial['cueOri'])
        
        # Flag to track if user responded
        response_made = False 
        
        # Frame Loop
        for frameN in range(fix_frames + cue_frames + probe_max_frames):
            # --- Drawing Logic ---
            if frameN < fix_frames:
                fixation.setAutoDraw(True)
                cue.setAutoDraw(False)
                probe.setAutoDraw(False)
            elif fix_frames <= frameN < (fix_frames + cue_frames):
                fixation.setAutoDraw(True)
                cue.setAutoDraw(True)
                probe.setAutoDraw(False)
            else:
                fixation.setAutoDraw(True)
                cue.setAutoDraw(False)
                probe.setAutoDraw(True)
                
                # Reset clock exactly when probe appears
                if frameN == (fix_frames + cue_frames):
                    kb.clock.reset() 
                    kb.clearEvents() 
            
            win.flip()
            
            # --- Input Checking ---
            if frameN >= (fix_frames + cue_frames):
                keys = kb.getKeys(keyList=['left', 'right', 'escape'], waitRelease=False)
                if keys:
                    resp = keys[0]
                    
                    if resp.name == 'escape':
                        current_loop.finished = True
                        blocks = [] 
                        win.close()
                        core.quit()
                        
                    # Calculate Accuracy
                    if (thisTrial['probeX'] > 0 and resp.name == 'right') or \
                       (thisTrial['probeX'] < 0 and resp.name == 'left'):
                        corr = 1
                    else:
                        corr = 0
                        
                    # SAVE DATA
                    current_loop.addData('resp', resp.name)
                    current_loop.addData('rt', resp.rt)
                    current_loop.addData('corr', corr)
                    # CRITICAL: Save the 'valid' status to the data so we can read it easily later
                    current_loop.addData('valid_type', thisTrial['valid'])
                    
                    response_made = True
                    break 

        # --- Handle Missed Trials ---
        if not response_made:
            current_loop.addData('resp', None)
            current_loop.addData('rt', None)
            current_loop.addData('corr', 0)
            current_loop.addData('valid_type', thisTrial['valid'])

        fixation.setAutoDraw(False)
        cue.setAutoDraw(False)
        probe.setAutoDraw(False)
        win.flip()
        
        thisExp.nextEntry()
# =========================================================
# PART C: THE RESULTS SCREEN (FIXED)
# =========================================================
import numpy as np # Ensure this is imported

if main_loop.thisN > 0: 
    try:
        # 1. GET DATA & FLATTEN IT
        # We use np.array().flatten() to smash any nested [[brackets]] 
        # into a simple flat list [1, 2, 3].
        
        # Get Correct/Incorrect (fill None with 0)
        raw_corr = main_loop.data['corr']
        all_corr = np.array(raw_corr)
        # Handle case where data might be None
        if all_corr.dtype == np.object_:
            # force None to 0 if found
            all_corr = np.array([0 if x is None else x for x in all_corr.flatten()])
        else:
            all_corr = all_corr.flatten()

        # Get Reaction Times
        raw_rt = main_loop.data['rt']
        all_rt = np.array(raw_rt).flatten()

        # Get Valid/Invalid Types
        raw_types = main_loop.data['valid_type']
        all_types = np.array(raw_types).flatten()

        # 2. CALCULATE GENERAL STATS
        n_trials = len(all_corr)
        n_correct = int(np.sum(all_corr)) 
        n_incorrect = n_trials - n_correct
        
        # 3. CALCULATE VALID vs INVALID RT
        valid_rts = []
        invalid_rts = []
        
        for i in range(n_trials):
            # Check if this specific trial exists and wasn't missed
            # We check if the RT is a number (not None or nan)
            current_rt = all_rt[i]
            current_corr = all_corr[i]
            current_type = all_types[i]
            
            # Helper to check if a value is a valid number
            is_valid_rt = (current_rt is not None) and (not np.isnan(current_rt))

            if current_corr == 1 and is_valid_rt:
                if current_type == 1:
                    valid_rts.append(current_rt) 
                else:
                    invalid_rts.append(current_rt)
        
        # Calculate Averages safely
        if len(valid_rts) > 0:
            avg_valid = float(np.mean(valid_rts)) * 1000
        else:
            avg_valid = 0.0
            
        if len(invalid_rts) > 0:
            avg_invalid = float(np.mean(invalid_rts)) * 1000
        else:
            avg_invalid = 0.0

        # 4. CREATE TEXT
        report_msg = (f"RESULTS\n"
                      f"----------------\n"
                      f"Total Incorrect: {n_incorrect}\n"
                      f"Total Correct:   {n_correct}\n\n"
                      f"Reaction Time (Matched): {avg_valid:.0f} ms\n"
                      f"Reaction Time (Misled):  {avg_invalid:.0f} ms\n\n"
                      f"Press SPACE to finish.")
                      
    except Exception as e:
        # Print the detailed error to the console so you can debug if needed
        print("Detailed Error:", e)
        report_msg = f"Error calculating:\n{e}\nPress SPACE."
else:
    report_msg = "No trials run.\nPress SPACE."

# Display
results_txt.setText(report_msg)
results_txt.draw()
win.flip()
event.waitKeys(keyList=['space'])

win.close()
core.quit()
